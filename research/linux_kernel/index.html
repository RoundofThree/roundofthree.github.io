<!DOCTYPE html>
<html lang="en">
<head>
<title>Reading the Linux kernel source code :: RoundofThree</title>
<meta content="text/html; charset=utf-8" http-equiv="content-type"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<meta content="The goal of this article is to explain the source code structure of the Linux kernel, its design choices and implementation. To start off, I will briefly read the Linux v1.0 code.
Note: The article is still updating.
An interesting file to read is the Makefile. I can make an idea of the dependencies.
Linux 1.0 Linux 1.0 source tree:
  boot: kernel bootstrap code, head.s, setup.s, bootSect.s
  drivers:" name="description"/>
<meta content="[hacking kaggle blog resume hackthebox machine-learning reverse-engineering infosec]" name="keywords"/>
<meta content="noodp" name="robots"/>
<link href="/research/linux_kernel/" rel="canonical"/>
<link href="/assets/style.css" rel="stylesheet"/>
<link href="/img/apple-touch-icon-192x192.png" rel="apple-touch-icon"/>
<link href="/favicon.png" rel="shortcut icon"/>
<meta content="summary" name="twitter:card"/>
<meta content="" name="twitter:site"/>
<meta content="RoundofThree" name="twitter:creator"/>
<meta content="en" property="og:locale"/>
<meta content="article" property="og:type"/>
<meta content="Reading the Linux kernel source code" property="og:title"/>
<meta content="The goal of this article is to explain the source code structure of the Linux kernel, its design choices and implementation. To start off, I will briefly read the Linux v1.0 code.
Note: The article is still updating.
An interesting file to read is the Makefile. I can make an idea of the dependencies.
Linux 1.0 Linux 1.0 source tree:
  boot: kernel bootstrap code, head.s, setup.s, bootSect.s
  drivers:" property="og:description"/>
<meta content="/research/linux_kernel/" property="og:url"/>
<meta content="RoundofThree" property="og:site_name"/>
<meta content="/favicon.png" property="og:image"/>
<meta content="2048" property="og:image:width"/>
<meta content="1024" property="og:image:height"/>
<meta content="2021-09-05 13:56:44 +0200 +0200" property="article:published_time"/>
</head>
<body class="orange">
<div class="container center headings--one-size">
<header class="header">
<div class="header__inner">
<div class="header__logo">
<a href="/">
<div class="logo">
    RoundofThree
  </div>
</a>
</div>
<div class="menu-trigger">menu</div>
</div>
<nav class="menu">
<ul class="menu__inner menu__inner--desktop">
<li><a href="/general">General</a></li>
<li><a href="/labs">Labs</a></li>
<li><a href="/research">Research</a></li>
<li><a href="/">Whoami</a></li>
</ul>
<ul class="menu__inner menu__inner--mobile">
<li><a href="/general">General</a></li>
<li><a href="/labs">Labs</a></li>
<li><a href="/research">Research</a></li>
<li><a href="/">Whoami</a></li>
</ul>
</nav>
</header>
<form action="/search/" id="search" method="get">
<label for="search-input" hidden="">Search site</label>
<input id="search-input" name="query" placeholder="Type here to search" type="text"/>
<input type="submit" value="search"/>
</form>
<div class="content">
<div class="post">
<h1 class="post-title">
<a href="/research/linux_kernel/">Reading the Linux kernel source code</a></h1>
<div class="post-meta">
<span class="post-date">
        2021-09-05 
      </span>
<span class="post-author">:: RoundofThree</span>
</div>
<span class="post-tags">
    
    #<a href="/tags/linux/">Linux</a> 
    
  </span>
<div class="table-of-contents">
<h2>
        
          Table of Contents
        
      </h2>
<nav id="TableOfContents">
<ul>
<li><a href="#linux-10">Linux 1.0</a>
<ul>
<li><a href="#boot">boot</a></li>
<li><a href="#init">init</a></li>
<li><a href="#lib">lib</a></li>
<li><a href="#include">include</a></li>
<li><a href="#kernel">kernel</a></li>
<li><a href="#fs">fs</a></li>
<li><a href="#mm">mm</a></li>
<li><a href="#net">net</a></li>
<li><a href="#ipc">ipc</a></li>
<li><a href="#drivers">drivers</a></li>
<li><a href="#tools">tools</a></li>
<li><a href="#zboot">zBoot</a></li>
</ul>
</li>
<li><a href="#linux-5x">Linux 5.x</a></li>
<li><a href="#references">References</a></li>
</ul>
</nav>
</div>
<div class="post-content"><div>
<p>The goal of this article is to explain the source code structure of the Linux kernel, its design choices and implementation. To start off, I will briefly read the Linux v1.0 code.</p>
<p><em>Note</em>: The article is still updating.</p>
<p>An interesting file to read is the Makefile. I can make an idea of the dependencies.</p>
<!-- raw HTML omitted -->
<h2 id="linux-10">Linux 1.0<a arialabel="Anchor" class="hanchor" href="#linux-10">⌗</a> </h2>
<p>Linux 1.0 source tree:</p>
<ul>
<li>
<p>boot: kernel bootstrap code, head.s, setup.s, bootSect.s</p>
</li>
<li>
<p>drivers:</p>
</li>
<li>
<p>fs: file system</p>
</li>
<li>
<p>mm: memory management</p>
</li>
<li>
<p>net: networking</p>
</li>
<li>
<p>include: header files</p>
</li>
<li>
<p>init: the first process executed</p>
</li>
<li>
<p>ipc: System V IPC</p>
</li>
<li>
<p>kernel: system calls</p>
</li>
<li>
<p>lib: library code</p>
</li>
<li>
<p>ibcs: Intel Binary Compatibility Standard. Compatibility library that would allow you to execute binaries built for old SCO systems on Linux. It got removed from Linux on later releases.</p>
</li>
<li>
<p>tools</p>
</li>
<li>
<p>zBoot</p>
</li>
</ul>
<h3 id="boot">boot<a arialabel="Anchor" class="hanchor" href="#boot">⌗</a> </h3>
<ol>
<li><strong>bootsect.S</strong> is loaded by bios_start at 0x7c00, copies itself to 0x90000, and jumps there. It then loads <strong>setup.S</strong> directly after itself (0x90200).</li>
<li>Use BIOS calls to write the message “\nLoading system…\n\n”, reads the system image directly at address 0x10000 from the boot device using BIOS calls, then turns off the floppy drive, saves the cursor position, turns off interrupts, and relocates the system image to address 0.</li>
<li>The addresses of a suitable Interrupt Descriptor Table (IDT) and Global Descriptor Table (GDT) are then loaded into the appropriate 386 registers. These tables are stored as data in the bootstrap code image.</li>
<li>The key-board buffer is emptied. The interrupts are reprogrammed. Then the process is switched to protected mode. It then jumps to execute the relocated system image.</li>
<li><strong>head.S</strong>. All of the foregoing code would be overwritten by the page tables. The code then performs a jump to the first address after GDT AND IDT, where a C-style call to _main of init/main.c is performed.</li>
</ol>
<p><em>Note</em>: In modern Linux, there is no longer a bootsector in a new bootable partition. Linux needs a bootloader, eg. GRUB, to write to the bootsector. GRUB writes to the <strong>MBR (Master Boot Record)</strong> of the primary drive. MBR contains the first 512 bytes of a partitioned data storage device; the first 440 bytes correspond to the <strong>first stage bootloader</strong> code, the remaining bytes correspond to the <strong>primary partition table</strong>. Each partition where an OS is installed starts with the <strong>VBR (Volume Boot Record)</strong>, which stores the main bootstrapping code. The boot manager, eg. GRUB, lets the user choose the <strong>second stage bootloader</strong> after the first stage bootloader is executed.</p>
<h3 id="init">init<a arialabel="Anchor" class="hanchor" href="#init">⌗</a> </h3>
<p><strong>start_kernel()</strong> performs these tasks. First the setups then enables interrupts.</p>
<ol>
<li>set_call_gate(&amp;default_ldt,lcall7);</li>
<li>PAGE_ALIGN and page_init</li>
<li>trap_init: system traps</li>
<li>init_IRQ</li>
<li>sched_init: scheduler</li>
<li>kmalloc_init, chr_dev_init, blk_dev_init, sti and calibrate_delay</li>
<li>(Optional) net_dev_init, scsi_dev_init</li>
<li>inode_init, file_table_init</li>
<li>mem_init</li>
<li>buffer_init: block device buffer system</li>
<li>time_init: clock</li>
<li>floppy_init</li>
<li>sock_init</li>
<li>ipc_init: System V IPC</li>
<li>sti</li>
<li>(Optional) Check math emulation</li>
<li>Move from kernel mode to user mode</li>
<li>Fork a child to perform init()</li>
<li>Schedule loop: idle</li>
</ol>
<p><em>Note</em>: sti means set interrupt flag.</p>
<p><strong>init()</strong> performs these tasks:</p>
<ol>
<li>setup(): read hard drive partition tables</li>
<li>Open /dev/tty1 in read-write mode</li>
<li>execve /etc/init, /bin/init, /sbin/init</li>
<li>Fork a child to execve /bin/sh with HOME=/usr/root</li>
<li>Wait for the child to die and print its exit code.</li>
<li>sync(): synchronize I/O operations</li>
<li>_exit(0)</li>
</ol>
<h3 id="lib">lib<a arialabel="Anchor" class="hanchor" href="#lib">⌗</a> </h3>
<p>Library functions. How are they included?</p>
<table>
<thead>
<tr>
<th>File</th>
<th>functions and description</th>
</tr>
</thead>
<tbody>
<tr>
<td>_exit.c</td>
<td>_exit(), interface to sys_exit()</td>
</tr>
<tr>
<td>close.c</td>
<td>close(), interface to sys_close()</td>
</tr>
<tr>
<td>ctype.c</td>
<td>_ctype[], lookup table for <code>&lt;ctype.h&gt;</code> functions</td>
</tr>
<tr>
<td>dup.c</td>
<td>dup(), interface to sys_dup()</td>
</tr>
<tr>
<td>errno.c</td>
<td>errno variable</td>
</tr>
<tr>
<td>execve.c</td>
<td>execve(), interface to sys_execve()</td>
</tr>
<tr>
<td>malloc.c</td>
<td>malloc(), implemented in mm</td>
</tr>
<tr>
<td>open.c</td>
<td>open(), interface to sys_open()</td>
</tr>
<tr>
<td>setsid.c</td>
<td>setsid(), interface to sys_setsid()</td>
</tr>
<tr>
<td>string.c</td>
<td>library version of <code>&lt;string.h&gt;</code></td>
</tr>
<tr>
<td>wait.c</td>
<td>wait(), interface to sys_waitpid()</td>
</tr>
<tr>
<td>write.c</td>
<td>write(), interface to sys_write()</td>
</tr>
</tbody>
</table>
<h3 id="include">include<a arialabel="Anchor" class="hanchor" href="#include">⌗</a> </h3>
<p>Kernel header files. Inline coded versions of libc functions. Some examples are:</p>
<ul>
<li>unistd.h: syscall numbers and syscallX macros <!-- raw HTML omitted --></li>
<li>wait.h: data structure definitions of wait_queue, semaphore, MUTEX, select_table <!-- raw HTML omitted --></li>
<li>tty.h <!-- raw HTML omitted --></li>
<li>sys.h: syscall entry points <!-- raw HTML omitted --></li>
</ul>
<h3 id="kernel">kernel<a arialabel="Anchor" class="hanchor" href="#kernel">⌗</a> </h3>
<p>System calls.</p>
<table>
<thead>
<tr>
<th>File</th>
<th>functions and description</th>
</tr>
</thead>
<tbody>
<tr>
<td>dma.c</td>
<td>DMA channel allocator</td>
</tr>
<tr>
<td>exit.c</td>
<td>exit and waitpid system functions</td>
</tr>
<tr>
<td>fork.c</td>
<td>fork</td>
</tr>
<tr>
<td>info.c</td>
<td>sysinfo() syscall</td>
</tr>
<tr>
<td>ioport.c</td>
<td>io permission bitmap code</td>
</tr>
<tr>
<td>irq.c</td>
<td>IRQ handling routines</td>
</tr>
<tr>
<td>itimer.c</td>
<td>itimer: interval timer</td>
</tr>
<tr>
<td>ldt.c</td>
<td>read, write, modify ldt (Local descriptor table): the LDT is an array of segment descriptors that can be referenced by user code.</td>
</tr>
<tr>
<td>mktime.c</td>
<td>time</td>
</tr>
<tr>
<td>module.c</td>
<td>loadable kernel modules handling</td>
</tr>
<tr>
<td>panic.c</td>
<td>panic when no interrupt handler is found</td>
</tr>
<tr>
<td>printk.c</td>
<td>print kernel message</td>
</tr>
<tr>
<td>ptrace.c</td>
<td>ptrace: syscall such that one process can control another, enabling the controller to inspect and manipulate the internal state of its target</td>
</tr>
<tr>
<td>sched.c</td>
<td>schedule</td>
</tr>
<tr>
<td>signal.c</td>
<td>sys signal</td>
</tr>
<tr>
<td>sys.c</td>
<td>proc_sel, sys_setpriority, sys_getpriority, sys_reboot, ctrl_alt_del, sys_setuid</td>
</tr>
<tr>
<td>sys_call.S</td>
<td>system-call and fault low-level handling routines</td>
</tr>
<tr>
<td>time.c</td>
<td>time related syscalls: time, stime, gettimeofday, settimeofday, adjtime</td>
</tr>
<tr>
<td>traps.c</td>
<td>handles hardware traps and faults after we have saved some state in ‘asm.s’</td>
</tr>
<tr>
<td>vsprintf.c</td>
<td>vsprintf(buffer, format, aptr)</td>
</tr>
</tbody>
</table>
<h3 id="fs">fs<a arialabel="Anchor" class="hanchor" href="#fs">⌗</a> </h3>
<p>File system functions. There are directories for different filesystems, eg. ext, ext2, minix, msdos…</p>
<p>Common functions:</p>
<table>
<thead>
<tr>
<th>File</th>
<th>functions and description</th>
</tr>
</thead>
<tbody>
<tr>
<td>binfmt_coff, binfmt_elf</td>
<td>Load COFF and ELF executables</td>
</tr>
<tr>
<td>block_dev.c</td>
<td>block_write(), block_read(), ll_rw_block()</td>
</tr>
<tr>
<td>buffer.c</td>
<td>buffer-cache functions: get_hash_table(), getblk(), sys_sync(), brelse(), bread(), buffer_init()</td>
</tr>
<tr>
<td>devices.c</td>
<td>block and character devices functions: register, unregister, open…</td>
</tr>
<tr>
<td>exec.c</td>
<td>read_head(), read_ind(), read_area(), do_execve()</td>
</tr>
<tr>
<td>fcntl.c</td>
<td>sys_dup2(), sys_dup(), sys_fcntl()</td>
</tr>
<tr>
<td>fifo.c</td>
<td>init_fifo(), fifo_open()</td>
</tr>
<tr>
<td>file_table.c</td>
<td>file_table[], insert_file_tree(), remove_file_free(), put_last_free, grow_files, file_table_init</td>
</tr>
<tr>
<td>filesystems.c</td>
<td>table of configured filesystems</td>
</tr>
<tr>
<td>inode.c</td>
<td>insert_inode_free(), insert_inode_hash(), grow_inodes(), sync_inodes(), bmap(), create_block(), iput(), get_empty_inode(), get_pipe_inode(), iget()…</td>
</tr>
<tr>
<td>ioctl.c</td>
<td>file_ioctl(), sys_ioctl()</td>
</tr>
<tr>
<td>locks.c</td>
<td>support for fcntl()’s F_GETLK, F_SETLK, and F_SETLKW calls, free_lock(), file_lock_table, file_lock_list</td>
</tr>
<tr>
<td>namei.c</td>
<td>getname(), putname(), lookup(), dir_namei(), namei(), open_namei(), do_mknod(), sys_mknod(), do_mkdir(), sys_mkdir(), do_rmdir(), sys_rmdir(), do_unlink(), sys_unlink(), do_symlink(), sys_symlink(), do_link(), sys_link(), do_rename(), sys_rename()</td>
</tr>
<tr>
<td>open.c</td>
<td>sys_truncate(), sys_utime(), sys_access(), sys_chdir(), sys_chroot(), sys_chmod(), sys_chown(), sys_open(), sys_creat(), sys_close()…</td>
</tr>
<tr>
<td>pipe.c</td>
<td>read_pipe(), write_pipe(), sys_pipe()</td>
</tr>
<tr>
<td>read_write.c</td>
<td>sys_readdir(), sys_lseek(), sys_read(), sys_write()</td>
</tr>
<tr>
<td>select.c</td>
<td>do_select(), sys_select(), free_wait(), check() (check file status)</td>
</tr>
<tr>
<td>stat.c</td>
<td>sys_stat(), sys_fstat(), sys_newstat(), sys_lstat(), sys_readlink(), cp_old_stat(), cp_new_stat()</td>
</tr>
<tr>
<td>super.c</td>
<td>handle super block tables. get_fs_type(), get_super(), put_super(), read_super(), get_unnamed_dev(), {do,sys}_{umount,mount}, mount_root, file_systems, super_blocks</td>
</tr>
</tbody>
</table>
<p>EXT2 functions:</p>
<table>
<thead>
<tr>
<th>File</th>
<th>functions and description</th>
</tr>
</thead>
<tbody>
<tr>
<td>acl.c</td>
<td>ext2_permission()</td>
</tr>
<tr>
<td>balloc.c</td>
<td>blocks allocation and deallocation routines. clear_block(), find_first_zero_bit(), load__block_bitmap()…</td>
</tr>
<tr>
<td>bitmap.c</td>
<td>nibblemap, ext2_count_free()</td>
</tr>
<tr>
<td>dcache.c</td>
<td>handling of dir cache used by lookup() and readdir()</td>
</tr>
<tr>
<td>dir.c</td>
<td>ext2_dir_read(), ext2_readdir(), ext2_check_dir_entry()</td>
</tr>
<tr>
<td>file.c</td>
<td>file operations</td>
</tr>
<tr>
<td>fsync.c</td>
<td>sync_block(), ext2_sync_file()…</td>
</tr>
<tr>
<td>ialloc.c</td>
<td>inodes allocation and deallocation.</td>
</tr>
<tr>
<td>inode.c</td>
<td>Goal-directed block allocation (?)</td>
</tr>
<tr>
<td>ioctl.c</td>
<td>ext2_ioctl()</td>
</tr>
<tr>
<td>namei.c</td>
<td>ext2_find_entry(), ext2_add_entry()</td>
</tr>
<tr>
<td>super.c</td>
<td>ext2_setup_super(), ext2_check_descriptors()…</td>
</tr>
<tr>
<td>symlink.c</td>
<td>ext2 symlink handlers: ext2_follow_link(), ext2_read_link()…</td>
</tr>
<tr>
<td>truncate.c</td>
<td>truncate: empty a file without deleting it.</td>
</tr>
</tbody>
</table>
<p>The free blocks are managed by bitmaps. The free inodes are managed by bitmaps. A file system contains several
blocks groups.  Each group contains 1 bitmap block for blocks, 1 bitmap
block for inodes, N blocks for the inode table and data blocks.</p>
<p>The file system contains group descriptors which are located after the
super block.  Each descriptor contains the number of the bitmap block and
the free blocks count in the block.  The descriptors are loaded in memory
when a file system is mounted (see ext2_read_super).</p>
<h3 id="mm">mm<a arialabel="Anchor" class="hanchor" href="#mm">⌗</a> </h3>
<p>Memory management functions.</p>
<table>
<thead>
<tr>
<th>File</th>
<th>functions and description</th>
</tr>
</thead>
<tbody>
<tr>
<td>memory.c</td>
<td>paged memory management functions. oom(), free_one_table(), copy_page_tables(), free_page(), put_page(), put_dirty_page(), share_page(), get_empty_pgtable(), do_page_fault(), show_mem()…</td>
</tr>
<tr>
<td>mmap.c</td>
<td>Memory mapping and ordering. do_mmap(), sys_mmap(), insert_vm_struct(), merge_segments()…</td>
</tr>
<tr>
<td>kmalloc.c</td>
<td>Kernel memory allocation. kmalloc(), kfree_s()</td>
</tr>
<tr>
<td>vmalloc.c</td>
<td>Virtual memory allocation. set_pgdir(), free_area_pages(), alloc_area_pages(), vfree(), vmalloc(), vread()…</td>
</tr>
<tr>
<td>swap.c</td>
<td>Swapping. rw_swap_page(), get_swap_page(), swap_duplicate(), swap_free(), swap_in(), swap_out(), free_page(), add_mem_queue() …</td>
</tr>
</tbody>
</table>
<h3 id="net">net<a arialabel="Anchor" class="hanchor" href="#net">⌗</a> </h3>
<p>TCP/IP networking and UNIX sockets. There are two directories, inet and unix. Unix is an implementation of the AF_UNIX network domain. Inet is an implementation of the TCP/IP suite.</p>
<p>Common files:</p>
<table>
<thead>
<tr>
<th>File</th>
<th>functions and description</th>
</tr>
</thead>
<tbody>
<tr>
<td>ddi.c</td>
<td>Device Driver Interface routines.</td>
</tr>
<tr>
<td>socket.c</td>
<td>sock_read(), sock_write(), sock_lseek(), sock_ioctl(), sock_close()…</td>
</tr>
<tr>
<td>Space.c</td>
<td>Defines which protocol modules and I/O device drivers get linked into the LINUX kernel.</td>
</tr>
</tbody>
</table>
<h3 id="ipc">ipc<a arialabel="Anchor" class="hanchor" href="#ipc">⌗</a> </h3>
<p>System V IPC.</p>
<table>
<thead>
<tr>
<th>File</th>
<th>functions and description</th>
</tr>
</thead>
<tbody>
<tr>
<td>msg.c</td>
<td>msg_init(), sys_msgsnd(), sys_msgrcv(), findkey(), newque(), sys_msgget(), freeque(), sys_msgctl()</td>
</tr>
<tr>
<td>sem.c</td>
<td>sem_init(), newary(), sys_semget()…</td>
</tr>
<tr>
<td>shm.c</td>
<td>shm_init(), newseg(), sys_shmget()…</td>
</tr>
<tr>
<td>util.c</td>
<td>sys_ipc(), ipc_init(), ipcperms()…</td>
</tr>
</tbody>
</table>
<h3 id="drivers">drivers<a arialabel="Anchor" class="hanchor" href="#drivers">⌗</a> </h3>
<p>Devices, classified into block, char, net, scsi, sound and FPU-emu.</p>
<p>A character device is a device whose driver communicates by sending and receiving single characters (bytes, octets), eg. serial ports, parallel ports, sound cards, keyboard.</p>
<p>A block device is a device whose driver communicates by sending entire blocks of data, eg. hard disks, USB cameras, Disk-On-Key.</p>
<h3 id="tools">tools<a arialabel="Anchor" class="hanchor" href="#tools">⌗</a> </h3>
<ul>
<li><strong>build.c</strong>: program that splices three images together into a kernel image that can be booted from PC BIOS startup. The three files are bootsect, setup and system.</li>
<li><strong>version.c</strong>: linux banner</li>
</ul>
<h3 id="zboot">zBoot<a arialabel="Anchor" class="hanchor" href="#zboot">⌗</a> </h3>
<p>Tools to compress and decompress the image: inflate.c, unzip.c, xtract.c, piggyback.c, misc.c.</p>
<!-- raw HTML omitted -->
<hr/>
<h2 id="linux-5x">Linux 5.x<a arialabel="Anchor" class="hanchor" href="#linux-5x">⌗</a> </h2>
<p>Linux source tree (current release):</p>
<ul>
<li>
<p>Documentation: documentation</p>
</li>
<li>
<p>arch: supported architectures</p>
</li>
<li>
<p>kernel:</p>
</li>
<li>
<p>init</p>
</li>
<li>
<p>mm</p>
</li>
<li>
<p>fs</p>
</li>
<li>
<p>net</p>
</li>
<li>
<p>include</p>
</li>
<li>
<p>lib</p>
</li>
<li>
<p>drivers</p>
</li>
<li>
<p>ipc</p>
</li>
<li>
<p>samples</p>
</li>
<li>
<p>scripts</p>
</li>
<li>
<p>block</p>
</li>
<li>
<p>sound</p>
</li>
<li>
<p>tools</p>
</li>
<li>
<p>usr</p>
</li>
<li>
<p>virt</p>
</li>
<li>
<p>certs</p>
</li>
<li>
<p>crypto</p>
</li>
<li>
<p>security</p>
</li>
</ul>
<h2 id="references">References<a arialabel="Anchor" class="hanchor" href="#references">⌗</a> </h2>
<ul>
<li><a href="https://kernelnewbies.org/Kernel001WalkThrough">https://kernelnewbies.org/Kernel001WalkThrough</a></li>
</ul>
</div></div>
</div>
</div>
<footer class="footer">
<div class="footer__inner">
<div class="copyright copyright--user">
<span>© 2021 RoundofThree</span>
</div>
</div>
</footer>
<script src="/assets/main.js"></script>
<script src="/assets/prism.js"></script>
</div>
</body>
</html>
