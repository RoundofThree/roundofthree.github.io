<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>TCP and UDP: Transport Layer Protocols</title>
      <link href="/2020/05/12/tcp-and-udp-transport-layer-protocols/"/>
      <url>/2020/05/12/tcp-and-udp-transport-layer-protocols/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>How to practice data structures &amp; algorithms my way to leetcoding</title>
      <link href="/2020/05/03/leetcode-frameworks/"/>
      <url>/2020/05/03/leetcode-frameworks/</url>
      
        <content type="html"><![CDATA[<p>Heya! This is the first of a series of articles about programming problems, which corresponds to my flag <strong>[365 leetcoding]</strong>. First, I am going to share my plan to practice <strong>data structures &amp; algorithms</strong>. This is the main skill tested in interviews, and of course the <strong>base</strong> of everything: the essence of thinking as a computer scientist.</p><p>Before diving into solving the programming problem, I think it is more efficient to have a picture of the main strategies we can use, so that when we see the problem, we can identify the best suited algorithmic paradigm by recognizing <strong>common patterns</strong>. Each paradigm has a corresponding <strong>framework</strong>, which guides me into how to structure my code.</p><p>Below I have collected the main frameworks I use:</p><ul><li>Recursion</li><li>Two pointers</li><li>Backtracking</li><li>Branch and bound</li><li>Brute-force search</li><li>Divide and conquer</li><li>Dynamic programming</li><li>Greedy algorithm</li><li>Prune and search</li></ul><p>TO DO:</p><ul><li>Java code for frameworks</li></ul><h2 id="Frameworks"><a href="#Frameworks" class="headerlink" title="Frameworks"></a>Frameworks</h2><h3 id="Trees-and-recursion"><a href="#Trees-and-recursion" class="headerlink" title="Trees and recursion"></a>Trees and recursion</h3><p>How do you identify a recursion problem?</p><ul><li>The problem needs to use the solution of similar subproblems.</li><li>A traversal.</li></ul><p>We observe that problems about trees often use recursion, because we can treat each of the children of a node as a new tree subproblem, thus the code looks like:</p><pre class="line-numbers language-Java"><code class="language-Java"> void traverse(TreeNode node) {   if(base case) {     // base case manipulation     return;   }   // possible update commands   traverse(node.left);   // possible update commands after solving for left child   traverse(node.right);   // possible update commands after solving for right }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>As an example, take a look at this Leetcode Hard tree problem:</p><h5 id="Leetcode-124-Binary-Tree-Maximum-Path-Sum"><a href="#Leetcode-124-Binary-Tree-Maximum-Path-Sum" class="headerlink" title="Leetcode 124. Binary Tree Maximum Path Sum"></a>Leetcode 124. <a href="https://leetcode.com/problems/binary-tree-maximum-path-sum/" target="_blank" rel="noopener">Binary Tree Maximum Path Sum</a></h5><blockquote><p>Given a non-empty binary tree, find the maximum path sum.<br><br>For this problem, a path is defined as any sequence of nodes from some<br>starting node to any node in the tree along the parent-child connections.<br>The path must contain at least one node and does not need to go through the root.</p></blockquote><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">int</span> ret <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MIN_VALUE<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxPathSum</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">oneSideMax</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">oneSideMax</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// base case</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// traverse left</span>  <span class="token keyword">int</span> left <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token function">oneSideMax</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// traverse right</span>  <span class="token keyword">int</span> right <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token function">oneSideMax</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// update the answer</span>  ret <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>ret<span class="token punctuation">,</span> left <span class="token operator">+</span> right <span class="token operator">+</span> ret<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// return the max path considering the tree with root = root</span>  <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span> <span class="token operator">+</span> root<span class="token punctuation">.</span>val<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>The framework is all about traversing all the nodes, and solving the problem for each node by updating a global variable <code>ret</code>. Note that we are using a <strong>global variable</strong> and an auxiliary function <code>oneSideMax()</code>. This is also a common pattern.</p><h3 id="Dynamic-programming"><a href="#Dynamic-programming" class="headerlink" title="Dynamic programming"></a>Dynamic programming</h3><p>Usually, DP problems ask for min or max conditions. To reach those conditions, we have to solve these problems:</p><ol><li><strong><em>Overlapping subproblem</em></strong>: think of a recursive trace that calls a function with same parameters several times, then this might suggest you to store computation results in a <strong>DP table</strong>.</li><li><strong><em>Optimal substructure</em></strong>: from the min or max state of some selected substructures, compute the <strong>optimal state</strong> for this structure. The subproblems should be independent.</li><li><strong><em>State transition equation</em></strong>: how do we measure <strong>state</strong>? This is often the key question in hard problems. The state of the problem functionally determines the result.</li></ol><p>Let’s analyse the coin change problem: How many ways are there to give change given a total amount and a set of coin values?</p><ul><li>Optimal substructure: say we decide to use a coin valued x, then the optimal structure is 1 + dp(amount-x). Since the amount of coins is unlimited, the subproblems are independent, so this is valid.</li><li>What is the state? Since the only change from the problem to the subproblem is the amount of money, the state is the amount of money (so it is passed as parameter).</li><li>Choose and choose the best, using <code>min()</code> or <code>max()</code> functions.<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> coin <span class="token operator">:</span> coins<span class="token punctuation">)</span> <span class="token punctuation">{</span>  res <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> <span class="token number">1</span><span class="token operator">+</span><span class="token function">dp</span><span class="token punctuation">(</span>n<span class="token operator">-</span>coin<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">return</span> res<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li>Base case: stop traversing when the <code>n</code>, total amount of money, is 0 or negative.<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>Now that we have the state transition equation, let’s optimize it using DP tables.<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> memo<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">coinChange</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> coins<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// dp table</span>memo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token function">dp</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> coins<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// helper</span><span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">dp</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> coins<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// base case</span><span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">if</span><span class="token punctuation">(</span>memo<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> memo<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// use dp table</span><span class="token keyword">int</span> res <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> coin <span class="token operator">:</span> coins<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">int</span> subproblem <span class="token operator">=</span> <span class="token function">dp</span><span class="token punctuation">(</span>n<span class="token operator">-</span>coin<span class="token punctuation">,</span> coins<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>subproblem <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">continue</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>  res <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> <span class="token number">1</span><span class="token operator">+</span>subproblem<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// put it in DP table before returning</span>memo<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>res <span class="token operator">==</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span><span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> res<span class="token punctuation">;</span><span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>In many cases, a bottom to top approach does not require recursion and saves space. We can compute from base case to coinChange(n) because coinChange only uses results from coinChange at a lower level. So, it only uses results that we know have already been computed.  </p><h3 id="Backtracking"><a href="#Backtracking" class="headerlink" title="Backtracking"></a>Backtracking</h3><p>Backtracking is essentially <strong>traversing a decision tree</strong>. The key is to use recursion to make a movement and then delete it. The result is stored as a global variable and is updated meanwhile. This is the framework:</p><pre class="line-numbers language-java"><code class="language-java">List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> ret <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">backtrack</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> path<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> choices<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>ending condition<span class="token punctuation">)</span> <span class="token punctuation">{</span>    ret<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// try every choice</span>  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> choice <span class="token operator">:</span> choices<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// make choice</span>    path<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>choice<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// try</span>    <span class="token function">backtrack</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> choices<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// delete choice</span>    path<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>choice<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Binary-search"><a href="#Binary-search" class="headerlink" title="Binary search"></a>Binary search</h3><h2 id="My-plan"><a href="#My-plan" class="headerlink" title="My plan"></a>My plan</h2><p><strong>Goal</strong>: Flag [365 leetcoding]</p><p><strong>Plan</strong>: Solve leetcode problems in this order:</p><pre><code>Recursion -&gt; Linked list -&gt; Stack -&gt; Queue -&gt; Two pointers -&gt; Sliding-window -&gt; hashing -&gt; sorting -&gt; binary search -&gt; trees -&gt; BST -&gt; Heaps -&gt; Graph basics -&gt; BFS -&gt; DFS -&gt; backtracking -&gt; greedy -&gt; Dynamic programming -&gt; advanced graph -&gt; Union find -&gt; bit manipulation</code></pre><p><strong>Action</strong>: Update the framework summary of this post as I learn.  </p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> framework </tag>
            
            <tag> algorithms </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
