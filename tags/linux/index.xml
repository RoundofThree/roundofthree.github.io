<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Linux on RoundofThree</title>
    <link>/tags/linux/</link>
    <description>Recent content in Linux on RoundofThree</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Â© 2021 RoundofThree</copyright>
    <lastBuildDate>Sun, 05 Sep 2021 13:56:44 +0200</lastBuildDate><atom:link href="/tags/linux/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Reading the Linux kernel source code</title>
      <link>/research/linux_kernel/</link>
      <pubDate>Sun, 05 Sep 2021 13:56:44 +0200</pubDate>
      
      <guid>/research/linux_kernel/</guid>
      <description>GOAL:
 Explain the kernel 1.0 [fixed]  Explain the Makefile to know how the kernel builds and the dependencies   Install the kernel in a VM  Create a root filesystem with buildroot, debootstrap, mkfs.ext2   Build the Rust equivalent (although the Linux kernel will NOT be rewritten in Rust in the foreseeable future)  Interesting files for kernel development:
 Makefile MAINTAINERS scripts/get_maintainer.pl scripts/checkpatch.pl  Linux source tree Linux 5.</description>
      <content>&lt;p&gt;GOAL:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Explain the kernel 1.0 [fixed]
&lt;ul&gt;
&lt;li&gt;Explain the Makefile to know how the kernel builds and the dependencies&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Install the kernel in a VM
&lt;ul&gt;
&lt;li&gt;Create a root filesystem with buildroot, debootstrap, mkfs.ext2&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Build the Rust equivalent (although the Linux kernel will NOT be rewritten in Rust in the foreseeable future)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Interesting files for kernel development:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Makefile&lt;/li&gt;
&lt;li&gt;MAINTAINERS&lt;/li&gt;
&lt;li&gt;scripts/get_maintainer.pl&lt;/li&gt;
&lt;li&gt;scripts/checkpatch.pl&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;linux-source-tree&#34;&gt;Linux source tree&lt;/h2&gt;
&lt;h3 id=&#34;linux-5x&#34;&gt;Linux 5.x&lt;/h3&gt;
&lt;p&gt;Linux source tree (current release):&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Documentation: documentation&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;arch: supported architectures&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;kernel:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;init&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;mm&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;fs&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;net&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;include&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;lib&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;drivers&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ipc&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;samples&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;scripts&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;block&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;sound&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;tools&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;usr&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;virt&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;certs&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;crypto&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;security&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;linux-10&#34;&gt;Linux 1.0&lt;/h3&gt;
&lt;p&gt;Linux 1.0 source tree:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;boot: kernel bootstrap code, head.s, setup.s, bootSect.s&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;drivers:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;fs: file system&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;mm: memory management&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;net: networking&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;include: header files&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;init: the first process executed&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ipc: System V IPC&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;kernel: system calls&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;lib: library code&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ibcs: Intel Binary Compatibility Standard. Compatibility library that would allow you to execute binaries built for old SCO systems on Linux. It got removed from Linux on later releases.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;tools: program that splices three images together into a kernel image that can be booted from PC BIOS startup&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;zBoot&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;boot&#34;&gt;boot&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;bootsect.S&lt;/strong&gt; is loaded by bios_start at 0x7c00, copies itself to 0x90000, and jumps there. It then loads &lt;strong&gt;setup.S&lt;/strong&gt; directly after itself (0x90200).&lt;/li&gt;
&lt;li&gt;Use BIOS calls to write the message &amp;ldquo;\nLoading system&amp;hellip;\n\n&amp;rdquo;, reads the system image directly at address 0x10000 from the boot device using BIOS calls, then turns off the floppy drive, saves the cursor position, turns off interrupts, and relocates the system image to address 0.&lt;/li&gt;
&lt;li&gt;The addresses of a suitable Interrupt Descriptor Table (IDT) and Global Descriptor Table (GDT) are then loaded into the appropriate 386 registers. These tables are stored as data in the bootstrap code image.&lt;/li&gt;
&lt;li&gt;The key-board buffer is emptied. The interrupts are reprogrammed. Then the process is switched to protected mode. It then jumps to execute the relocated system image.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;head.S&lt;/strong&gt;. All of the foregoing code would be overwritten by the page tables. The code then performs a jump to the first address after GDT AND IDT, where a C-style call to _main of init/main.c is performed.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;em&gt;Note&lt;/em&gt;: In modern Linux, there is no longer a bootsector in a new bootable partition. Linux needs a bootloader, eg. GRUB, to write to the bootsector. GRUB writes to the &lt;strong&gt;MBR (Master Boot Record)&lt;/strong&gt; of the primary drive. MBR contains the first 512 bytes of a partitioned data storage device; the first 440 bytes correspond to the &lt;strong&gt;first stage bootloader&lt;/strong&gt; code, the remaining bytes correspond to the &lt;strong&gt;primary partition table&lt;/strong&gt;. Each partition where an OS is installed starts with the &lt;strong&gt;VBR (Volume Boot Record)&lt;/strong&gt;, which stores the main bootstrapping code. The boot manager, eg. GRUB, lets the user choose the &lt;strong&gt;second stage bootloader&lt;/strong&gt; after the first stage bootloader is executed.&lt;/p&gt;
&lt;h4 id=&#34;init&#34;&gt;init&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;start_kernel()&lt;/strong&gt; performs these tasks. First the setups then enables interrupts.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;set_call_gate(&amp;amp;default_ldt,lcall7);&lt;/li&gt;
&lt;li&gt;PAGE_ALIGN and page_init&lt;/li&gt;
&lt;li&gt;trap_init: system traps&lt;/li&gt;
&lt;li&gt;init_IRQ&lt;/li&gt;
&lt;li&gt;sched_init: scheduler&lt;/li&gt;
&lt;li&gt;kmalloc_init, chr_dev_init, blk_dev_init, sti and calibrate_delay&lt;/li&gt;
&lt;li&gt;(Optional) net_dev_init, scsi_dev_init&lt;/li&gt;
&lt;li&gt;inode_init, file_table_init&lt;/li&gt;
&lt;li&gt;mem_init&lt;/li&gt;
&lt;li&gt;buffer_init: block device buffer system&lt;/li&gt;
&lt;li&gt;time_init: clock&lt;/li&gt;
&lt;li&gt;floppy_init&lt;/li&gt;
&lt;li&gt;sock_init&lt;/li&gt;
&lt;li&gt;ipc_init: System V IPC&lt;/li&gt;
&lt;li&gt;sti&lt;/li&gt;
&lt;li&gt;(Optional) Check math emulation&lt;/li&gt;
&lt;li&gt;Move from kernel mode to user mode&lt;/li&gt;
&lt;li&gt;Fork a child to perform init()&lt;/li&gt;
&lt;li&gt;Schedule loop: idle&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;em&gt;Note&lt;/em&gt;: sti means set interrupt flag.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;init()&lt;/strong&gt; performs these tasks:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;setup(): read hard drive partition tables&lt;/li&gt;
&lt;li&gt;Open /dev/tty1 in read-write mode&lt;/li&gt;
&lt;li&gt;execve /etc/init, /bin/init, /sbin/init&lt;/li&gt;
&lt;li&gt;Fork a child to execve /bin/sh with HOME=/usr/root&lt;/li&gt;
&lt;li&gt;Wait for the child to die and print its exit code.&lt;/li&gt;
&lt;li&gt;sync(): synchronize I/O operations&lt;/li&gt;
&lt;li&gt;_exit(0)&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;lib&#34;&gt;lib&lt;/h4&gt;
&lt;p&gt;Library functions. How are they included?&lt;/p&gt;
&lt;p&gt;| _exit.c | _exit(), interface to sys_exit() |
| close.c | close(), interface to sys_close() |
| ctype.c | _ctype[], lookup table for &lt;code&gt;&amp;lt;ctype.h&amp;gt;&lt;/code&gt; functions |
| dup.c | dup(), interface to sys_dup() |
| errno.c | errno variable |
| execve.c | execve(), interface to sys_execve() |
| malloc.c | malloc(), implemented in mm |
| open.c | open(), interface to sys_open() |
| setsid.c | setsid(), interface to sys_setsid() |
| string.c | library version of &lt;code&gt;&amp;lt;string.h&amp;gt;&lt;/code&gt; |
| wait.c | wait(), interface to sys_waitpid() |
| write.c | write(), interface to sys_write() |&lt;/p&gt;
&lt;h4 id=&#34;include&#34;&gt;include&lt;/h4&gt;
&lt;p&gt;Kernel header files. Inline coded versions of libc functions. Some examples are:&lt;/p&gt;
&lt;p&gt;unistd.h: syscall numbers and syscallX macros &lt;!-- raw HTML omitted --&gt;
wait.h: data structure definitions of wait_queue, semaphore, MUTEX, select_table &lt;!-- raw HTML omitted --&gt;
tty.h &lt;!-- raw HTML omitted --&gt;
sys.h: syscall entry points &lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h4 id=&#34;kernel&#34;&gt;kernel&lt;/h4&gt;
&lt;p&gt;System calls.&lt;/p&gt;
&lt;p&gt;| dma.c | DMA channel allocator |
| exit.c | exit and waitpid system functions |
| fork.c | fork |
| info.c | sysinfo() syscall |
| ioport.c | io permission bitmap code |
| irq.c | IRQ handling routines |
| itimer.c | itimer: interval timer |
| ldt.c | read, write, modify ldt (Local descriptor table): the LDT is an array of segment descriptors that can be referenced by user code. |
| mktime.c | time |
| module.c | loadable kernel modules handling |
| panic.c | panic when no interrupt handler is found |
| printk.c | print kernel message |
| ptrace.c | ptrace: syscall such that one process can control another, enabling the controller to inspect and manipulate the internal state of its target |
| sched.c | schedule |
| signal.c | sys signal |
| sys.c | proc_sel, sys_setpriority, sys_getpriority, sys_reboot, ctrl_alt_del, sys_setuid |
| sys_call.S | system-call and fault low-level handling routines |
| time.c | time related syscalls: time, stime, gettimeofday, settimeofday, adjtime |
| traps.c | handles hardware traps and faults after we have saved some state in &amp;lsquo;asm.s&amp;rsquo; |
| vsprintf.c | vsprintf(buffer, format, aptr) |&lt;/p&gt;
&lt;h4 id=&#34;fs&#34;&gt;fs&lt;/h4&gt;
&lt;p&gt;File system functions. There are directories for different filesystems, eg. ext, ext2, minix, msdos&amp;hellip;&lt;/p&gt;
&lt;p&gt;Common functions:
| binfmt_coff, binfmt_elf | Load COFF and ELF executables |
| block_dev.c | block_write(), block_read(), ll_rw_block() |
| buffer.c | buffer-cache functions: get_hash_table(), getblk(), sys_sync(), brelse(), bread(), buffer_init() |
| devices.c | block and character devices functions: register, unregister, open&amp;hellip; |
| exec.c | read_head(), read_ind(), read_area(), do_execve() |
| fcntl.c | sys_dup2(), sys_dup(), sys_fcntl() |
| fifo.c | init_fifo(), fifo_open() |
| file_table.c | file_table[], insert_file_tree(), remove_file_free(), put_last_free, grow_files, file_table_init |
| filesystems.c | table of configured filesystems |
| inode.c | insert_inode_free(), insert_inode_hash(), grow_inodes(), sync_inodes(), bmap(), create_block(), iput(), get_empty_inode(), get_pipe_inode(), iget()&amp;hellip; |
| ioctl.c | file_ioctl(), sys_ioctl() |
| locks.c | support for fcntl()&amp;rsquo;s F_GETLK, F_SETLK, and F_SETLKW calls, free_lock(), file_lock_table, file_lock_list |
| namei.c | getname(), putname(), lookup(), dir_namei(), namei(), open_namei(), do_mknod(), sys_mknod(), do_mkdir(), sys_mkdir(), do_rmdir(), sys_rmdir(), do_unlink(), sys_unlink(), do_symlink(), sys_symlink(), do_link(), sys_link(), do_rename(), sys_rename() |
| open.c | sys_truncate(), sys_utime(), sys_access(), sys_chdir(), sys_chroot(), sys_chmod(), sys_chown(), sys_open(), sys_creat(), sys_close()&amp;hellip; |
| pipe.c | read_pipe(), write_pipe(), sys_pipe() |
| read_write.c | sys_readdir(), sys_lseek(), sys_read(), sys_write() |
| select.c | do_select(), sys_select(), free_wait(), check() (check file status) |
| stat.c | sys_stat(), sys_fstat(), sys_newstat(), sys_lstat(), sys_readlink(), cp_old_stat(), cp_new_stat() |
| super.c | handle super block tables. get_fs_type(), get_super(), put_super(), read_super(), get_unnamed_dev(), {do,sys}_{umount,mount}, mount_root, file_systems, super_blocks |&lt;/p&gt;
&lt;p&gt;EXT2 functions:&lt;/p&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;h4 id=&#34;mm&#34;&gt;mm&lt;/h4&gt;
&lt;h4 id=&#34;net&#34;&gt;net&lt;/h4&gt;
&lt;h4 id=&#34;ipc&#34;&gt;ipc&lt;/h4&gt;
&lt;h4 id=&#34;drivers&#34;&gt;drivers&lt;/h4&gt;
&lt;h4 id=&#34;tools&#34;&gt;tools&lt;/h4&gt;
&lt;h4 id=&#34;zboot&#34;&gt;zBoot&lt;/h4&gt;
&lt;h2 id=&#34;playing-the-kernel-001&#34;&gt;Playing the kernel 0.01&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;git clone https://github.com/mariuz/linux-0.01.git
make -j8
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;cloning-the-kernel-10&#34;&gt;Cloning the kernel 1.0&lt;/h2&gt;
&lt;p&gt;Clone the fixed kernel, which can be compiled in Ubuntu 20.04, at &lt;a href=&#34;https://github.com/lasek0/linux-1.0.git&#34;&gt;https://github.com/lasek0/linux-1.0.git&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;building-the-kernel&#34;&gt;Building the kernel&lt;/h2&gt;
&lt;p&gt;First, configure the kernel.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;make ARCH&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;x86_64 x86_64_defconfig 
make ARCH&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;x86_64 menuconfig
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;In our case of a kernel 1.0, simply:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;make config
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This is because kernel 1.0 does not have an &lt;code&gt;arch&lt;/code&gt; directory containing default configs for different architectures.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Second, build the kernel using make and the generated .config file.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;make -j8
make -j8 modules_install &lt;span style=&#34;color:#75715e&#34;&gt;# install LKMs&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;In our case,&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;make -j8
make -j8 dep
make clean
make -j8
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;installing-the-kernel&#34;&gt;Installing the kernel&lt;/h2&gt;
&lt;p&gt;The kernel image is stored at arch/x86/boot/bzImage for the current release.
The kernel image is stored at zImage  for kernel 1.0.&lt;/p&gt;
&lt;p&gt;To boot the kernel we need a root filesystem. I will experiment with three choices: buildroot, qemu-img + debootstrap, mkfs + bochs.&lt;/p&gt;
&lt;h3 id=&#34;buildroot&#34;&gt;Buildroot&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;git clone git://git.buildroot.net/buildroot
cd buildroot

make menuconfig &lt;span style=&#34;color:#75715e&#34;&gt;# select x86_64 and ext4 for current release&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;# OR&lt;/span&gt;
make qemu_x86_defconfig &lt;span style=&#34;color:#75715e&#34;&gt;# select i386 and ext2 for kernel 1.0 &lt;/span&gt;
make -j8
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The root filesystem is stored at buildroot/output/images/.&lt;/p&gt;
&lt;p&gt;Experiment outcome:&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;scripts/Kconfig.include:39: compiler &amp;lsquo;/home/remnux/linux_dev/buildroot/output/host/bin/i686-buildroot-linux-uclibc-gcc&amp;rsquo; not found&lt;/p&gt;
&lt;h3 id=&#34;qemu-img--debootstrap&#34;&gt;qemu-img + debootstrap&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;IMG&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;qemu-image.img
DIR&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;mount-point.dir
&lt;span style=&#34;color:#75715e&#34;&gt;# create disk image of size 1g&lt;/span&gt;
qemu-img create $IMG 1g
&lt;span style=&#34;color:#75715e&#34;&gt;# make filesystem EXT2&lt;/span&gt;
mkfs.ext2 $IMG
mkdir $DIR
&lt;span style=&#34;color:#75715e&#34;&gt;# mount disk image on directory using a loop device&lt;/span&gt;
sudo mount -o loop $IMG $DIR
&lt;span style=&#34;color:#75715e&#34;&gt;# install a Debian base system into the directory&lt;/span&gt;
sudo debootstrap --arch amd64 jessie $DIR
&lt;span style=&#34;color:#75715e&#34;&gt;# unmount the directory&lt;/span&gt;
sudo umount $DIR
rmdir $DIR
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Experiment outcome:&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h3 id=&#34;mkfs--bochs&#34;&gt;mkfs + bochs&lt;/h3&gt;
&lt;p&gt;See INFO.TXT.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;cd linux-1.0
touch myfs
truncate -s &lt;span style=&#34;color:#ae81ff&#34;&gt;1474560&lt;/span&gt; myfs
mkfs.ext2 -b &lt;span style=&#34;color:#ae81ff&#34;&gt;1024&lt;/span&gt; myfs
mkdir myfsdir
sudo mount myfs myfsdir/
sudo mkdir myfsdir/bin/
sudo mkdir myfsdir/dev/
mkdir tmp
cat &amp;gt; tmp/init.c &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;lt;&amp;lt; EOF
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;#include &amp;lt;linux/unistd.h&amp;gt;
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;#include &amp;lt;linux/types.h&amp;gt;
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;int errno;
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;static inline _syscall3(int,write,int,fd,const char *,buf,off_t,count)
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;int _start(void){
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;  write(1, &amp;#34;Hello World!&amp;#34;, 12);  
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;  for(;;);
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;}
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;EOF&lt;/span&gt;
gcc tmp/init.c -o tmp/init.o -static -c &lt;span style=&#34;color:#ae81ff&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;	-Wall -Wstrict-prototypes -O2  -fomit-frame-pointer -pipe &lt;span style=&#34;color:#ae81ff&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;        -w -m32 -I./include/ -std&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;gnu89 &lt;span style=&#34;color:#ae81ff&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;        -fno-stack-protector -fno-builtin -mmanual-endbr &lt;span style=&#34;color:#ae81ff&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;        -fno-reorder-blocks-and-partition -fno-pie
ld -m elf_i386 tmp/init.o -o tmp/init
&lt;span style=&#34;color:#75715e&#34;&gt;# place init binary at /bin of rootfs&lt;/span&gt;
sudo mv tmp/init myfsdir/bin/
rm -rf tmp
&lt;span style=&#34;color:#75715e&#34;&gt;# make a device c 4 1 = /dev/tty1         First virtual console&lt;/span&gt;
sudo mknod myfsdir/dev/tty1 c &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
sudo umount myfsdir/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Experiment outcome:&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;Nothing happens in QEMU.
Bochs:&lt;/p&gt;
&lt;h2 id=&#34;testing-the-kernel-in-qemu&#34;&gt;Testing the kernel in QEMU&lt;/h2&gt;
&lt;p&gt;QEMU command arguments:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;-kernel: kernel image&lt;/li&gt;
&lt;li&gt;-hda: rootfs image&lt;/li&gt;
&lt;li&gt;-append: command line arguments supplied to the kernel&lt;/li&gt;
&lt;li&gt;-s and -S: for remote debugging purposes. Opens port 1234&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Without root filesystem:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;qemu-system-i386 -no-kvm -kernel zImage -drive file&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;/dev/zero,format&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;raw,index&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;0,media&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;disk -append &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;root=/dev/zero console=ttyS0&amp;#34;&lt;/span&gt; -serial stdio -display none
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;With root filesystem and using the rootfs generated by buildroot:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;qemu-system-i386 -kernel zImage &lt;span style=&#34;color:#ae81ff&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;-boot c -m 2049M -drive file&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;../buildroot/output/images/rootfs.ext2,format&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;raw,index&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;0,media&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;disk &lt;span style=&#34;color:#ae81ff&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;-append &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;root=/dev/sda rw console=tty,115200 acpi=off nokaslr&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;-serial stdio -display none
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;With root filesystem and using the rootfs generated by debootstrap:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;qemu-system-x86_64 -kernel zImage &lt;span style=&#34;color:#ae81ff&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;-hda qemu-image.img -append &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;root=/dev/sda rw console=ttyS0,115200 acpi=off nokaslr&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;-serial stdio -display none
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;With root filesystem and using the rootfs generated by mkfs:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;qemu-system-i386 -kernel zImage &lt;span style=&#34;color:#ae81ff&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;-hda myfs -append &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;root=/dev/sda rw console=ttyS0,115200 acpi=off nokaslr&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&lt;/span&gt;-serial stdio -display none
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Same as above but using bochs:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;bochs -f bochsrc -q
&lt;span style=&#34;color:#75715e&#34;&gt;# config: TODO&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;h2 id=&#34;this-is-for-linux-001&#34;&gt;THIS IS FOR LINUX 0.01:&lt;/h2&gt;
&lt;p&gt;With fetched old linux fs image:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;wget http://draconux.free.fr/download/os-dev/linux0.01/Image/hd_oldlinux.img.zip
unzip hd_oldlinux.img
qemu -hdb hd_oldlinux.img -fda linux0.01-3.5.img -boot a
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Questions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;What is the difference between hdb and hda?&lt;/li&gt;
&lt;li&gt;What is the -boot option?&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;If you want to debug the kernel using GDB, this will open port 1234 for debugging and disable KASLR. Note the &lt;code&gt;-s&lt;/code&gt;, ``-S&lt;code&gt;and&lt;/code&gt;nokaslr` flags.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;qemu-system-x86_64 -s -S -no-kvm -kernel arch/x86/boot/bzImage -hda /dev/zero -append &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;root=/dev/zero console=ttyS0 nokaslr&amp;#34;&lt;/span&gt; -serial stdio -display none
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;references&#34;&gt;References&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.collabora.com/news-and-blog/blog/2017/01/16/setting-up-qemu-kvm-for-kernel-development/&#34;&gt;https://www.collabora.com/news-and-blog/blog/2017/01/16/setting-up-qemu-kvm-for-kernel-development/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mapopa.blogspot.com/2008/09/linux-0.html&#34;&gt;https://mapopa.blogspot.com/2008/09/linux-0.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://kernelnewbies.org/Kernel001WalkThrough&#34;&gt;https://kernelnewbies.org/Kernel001WalkThrough&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
  </channel>
</rss>
